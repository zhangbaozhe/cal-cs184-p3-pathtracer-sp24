<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    padding: 0px;
    width: 100%;
    max-width: 1000px;
    margin-right: auto;
    margin-left: auto;
    border-collapse: separate;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
  pre {
    white-space: pre-wrap;
    background: hsl(30,80%,90%);
  }
  code {
    background: rgb(137, 132, 186);
  }
</style>
<title>Computer Graphics Path Tracer</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/contrib/auto-render.min.js"></script>
</head>


<body>



<h1 align="middle">Computer Graphics, Spring 2024</h1>
<h1 align="middle">Path Tracer</h1>
<h2 align="middle">Baozhe ZHANG</h2>

<br><br>

<div>

<h2 align="middle">Overview</h2>
<p>
  In this assignment, the task is to achieve a path tracer for rendering images of 3D scenes. The path tracer is implemented in C++ and is able to render images of 3D scenes with various materials, lighting, and camera configurations. The path tracer in implemented in several parts, each building on the previous part. 
  <ul>
    <li>Part 1: Ray Generation and Scene Intersection</li>
    <li>Part 2: Bounding Volume Hierarchy</li>
    <li>Part 3: Direct Illumination</li>
    <li>Part 4: Global Illumination</li>
    <li>Part 5: </li>
  </ul>
  
</p>

<h2 align="middle">Part I: Ray Generation and Scene Intersection</h2>
<p>
  In this part, the task is to implement the ray generation and scene intersection. The ray generation is implemented in the <code>Camera</code> class, which generates rays for each pixel in the image plane. The scene intersection is implemented in the <code>Triangle</code> and <code>Sphere</code> classes, which check for intersections between rays and scene objects. The scene objects are represented as <code>Primitive</code> objects, which can be spheres, triangles, or other shapes. The intersection tests are implemented for spheres and triangles. The ray generation and scene intersection are tested with a simple scene containing spheres and triangles. The images rendered by the path tracer are shown below.
</p>

<div align="middle">
  <table style="width:100%">
    <tr align="center">
      <td>
        <img src="images/part1_CBspheres_screenshot_4-3_17-3-28.png" align="middle" width="400px"/>
        <figcaption><b>Figure 1a:</b> CBspheres</figcaption>
      </td>
      <td>
        <img src="images/part1_banana_screenshot_4-3_17-4-24.png" align="middle" width="400px"/>
        <figcaption><b>Figure 1b:</b> Banana</figcaption>
      </td>
    </tr>
    <tr align="center">
      <td>
        <img src="images/part1_cow_screenshot_4-3_17-0-9.png" align="middle" width="400px"/>
        <figcaption><b>Figure 1c:</b> Cow</figcaption>
      </td>
      <td>
        <img src="images/part1_beetle_screenshot_4-3_17-2-30.png" align="middle" width="400px"/>
        <figcaption><b>Figure 1d:</b> Beetle</figcaption>
      </td>
    </tr>
  </table>
</div>
<br>

<p>
  As for the triangle intersection algorithm, the Möller-Trumbore algorithm<sup><a href="https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm">[1]</a></sup> is used to calculate the intersection between a ray and a triangle. 

  The Möller-Trumbore algorithm is a fast ray-triangle intersection algorithm that is widely used in computer graphics. The algorithm describes a method for calculating the intersection between a ray and a triangle in 3D space. It is based on the idea of finding the intersection point between the ray and the plane of the triangle, and then checking if the intersection point is inside the triangle. 

  It first check if the ray is parallel to the triangle, if so, return false. Assume the triangle's three vertices are $v_1$, $v_2$, and $v_3$. The ray is $O + t D$. Using the barycentric coordinate, if there is an intersection with the plane of the triangle, the intersection point can be represented as $P = O + t D = v_1 + u (v_2 - v_1) + v (v_3 - v_1)$. The Möller-Trumbore algorithm calculates the barycentric coordinates $u$ and $v$ by solving the following equations:
  $$
  \begin{bmatrix}
    \vert & \vert & \vert \\
    -D & v_2 - v_1 & v_3 - v_1 \\
    \vert & \vert & \vert
  \end{bmatrix}
  \begin{bmatrix}
  t \\ u \\ v
  \end{bmatrix}
   = O - v_1
  $$
  If $u \geq 0$, $v \geq 0$, and $u + v \leq 1$, then the intersection point is inside the triangle.
</p>

<h2 align="middle">Part II: Bounding Volume Hierarchy</h2>

<p>
  Without BVH implemented, rendering the cow mesh using the following command on my computer (AMD Ryzen 5 5600H) with 8 threadsuses about 30 seconds.
  <pre>
    ./pathtracer -t 8 -r 800 600 -f cow.png ../dae/meshedit/cow.dae
  </pre>
  To illustrate the efficiency of BVH, I use the following commands to render a scene of Max Planck with and without BVH.
  <pre>
    time ./pathtracer -t 1 -r 480 360 -f output.png ../dae/meshedit/maxplanck.dae
  </pre>
  The rendering time for the program with proper BVH implemented is about <code>0m0.583s</code>, while the rendering time for the program without BVH is about <code>2m30.670s</code>. The BVH significantly improves the rendering efficiency.
</p>

<p>
  The BVH construction algorithm I use is simple. It is a top-down construction algorithm. The algorithm is as follows:
  <ol>
    <li>Choose a splitting axis (x, y, or z) based on the longest axis of the bounding box of the current node.</li>
    <li>Sort the primitives based on the centroid of the bounding box along the splitting axis.</li>
    <li>Split the primitives into two groups based on the median of the splitting axis</li>
    <li>Recursively construct the BVH for the two groups.</li>
  </ol>
  The second step is the most time-consuming step. I use the C++ standard library function <code>std::sort</code> to sort the primitives. The sorting is done in-place, so it does not require additional memory. By sorting the primitives in $[start, end)$, the primitives with indices in $[start, mid)$ are in the left group, and the primitives with indices in $[mid, end)$ are in the right group. This operation ensures that the bounding boxes of the left group and the right group are splitted as much as possible, enhancing the later intersection test efficiency.

  Below are some of the normal shading images rendered by the path tracer with BVH implemented.
</p>

<div align="middle">
  <table style="width:100%">
    <tr align="center">
      <td>
        <img src="images/part2_bunny_screenshot_4-4_16-56-58.png" align="middle" width="400px"/>
        <figcaption><b>Figure 2a:</b> Bunny</figcaption>
      </td>
      <td>
        <img src="images/part2_CBlucy_screenshot_4-4_16-53-28.png" align="middle" width="400px"/>
        <figcaption><b>Figure 2b:</b> CBlucy</figcaption>
      </td>
    </tr>
    <tr align="center">
      <td>
        <img src="images/part2_maxplanck_screenshot_4-4_16-54-31.png" align="middle" width="400px"/>
        <figcaption><b>Figure 2c:</b> Max Planck</figcaption>
      </td>
      <td>
        <img src="images/part2_peter_screenshot_4-4_16-55-18.png" align="middle" width="400px"/>
        <figcaption><b>Figure 2d:</b> Peter</figcaption>
      </td>
    </tr>
  </table>
</div>

<h2 align="middle">Part III: Direct Illumination</h2>

<p>
  Direct illumination only counts for zero-bounce and one-bounce lights, i.e., the light source &rightarrow; the camera and light source &rightarrow; the object &rightarrow; the camera, respectively. 
  For the diffuse lambertian BRDF, given the incoming direction $\omega_i$ and the outgoing direction $\omega_o$, 
  the radiance of the outgoing light is 
  $$
  L_o(p, \omega_o) = \int_{\Omega}f(\omega_i \rightarrow \omega_o) L_i(p, \omega_i) \cos{\theta_i} d\omega
  = f_{\text{lambert}} L_i \int_{\Omega} \cos{\theta_i} d\omega = f_{\text{lambert}} L_i \pi
  $$
  where $f_{\text{lambert}}$ is the BRDF of the object, $L_i$ is the incoming radiance, and $\theta_i$ is the angle between the incoming direction and the normal of the object.
  $$
  f_{\text{lambert}} = \frac{\text{albedo}}{\pi} = \frac{L_o}{L_i\pi}
  $$
  Therefore, the BRDF is $f(\omega_o, \omega_i) = \frac{\rho}{\pi}$, where $\rho$ is the albedo of the object. 
  This is defined in the <code>DiffuseBSDF::f(...)</code> method. 
  The difference between <code>Pathtracer::estimate_direct_lighting_hemisphere(...)</code> and 
  <code>Pathtracer::estimate_direct_lighting_importance(...)</code> is how the bounced ray is generated.
  In the hemisphere sampling, the bounced ray is generated by sampling a random direction on the hemisphere around the 
  hit point from the camera ray. In the importance sampling, the bounced ray is generated by sampling a random direction
  between the hit point and the light source.

  Below show some of the images rendered by the path tracer using uniform-hemisphere (Fig. 3a - 3d) and importance (Fig. 3e - 3h) sampling.
</p>
<div>
  <table style="width: 100%">
    <tr align="center">
      <td>
        <img src="images/part3_s16_l8_CBbunny_uniform.png" align="middle" width="200px"/>
        <figcaption><b>Figure 3a:</b> s = 16, l = 8</figcaption>
      </td>
      <td>
        <img src="images/part3_s64_l8_CBbunny_uniform.png" align="middle" width="200px"/>
        <figcaption><b>Figure 3b:</b> s = 64, l = 8</figcaption>
      </td>
      <td>
        <img src="images/part3_s16_l8_CBspheres_lambertian_uniform.png" align="middle" width="200px"/>
        <figcaption><b>Figure 3c:</b> s = 16, l = 8</figcaption>
      </td>
      <td>
        <img src="images/part3_s64_l8_CBspheres_lambertian_uniform.png" align="middle" width="200px"/>
        <figcaption><b>Figure 3d:</b> s = 64, l = 8</figcaption>
      </td>
    </tr>
    <tr align="center">
      <td>
        <img src="images/part3_s16_l8_CBbunny_importance.png" align="middle" width="200px"/>
        <figcaption><b>Figure 3e:</b> s = 16, l = 8</figcaption>
      </td>
      <td>
        <img src="images/part3_s64_l8_CBbunny_importance.png" align="middle" width="200px"/>
        <figcaption><b>Figure 3f:</b> s = 64, l = 8</figcaption>
      </td>
      <td>
        <img src="images/part3_s16_l8_CBspheres_lambertian_importance.png" align="middle" width="200px"/>
        <figcaption><b>Figure 3g:</b> s = 16, l = 8</figcaption>
      </td>
      <td>
        <img src="images/part3_s64_l8_CBspheres_lambertian_importance.png" align="middle" width="200px"/>
        <figcaption><b>Figure 3h:</b> s = 64, l = 8</figcaption>
      </td>
    </tr>
  </table>
</div>
<p>
  Using the importance sampling, below are some of the figures showing that the noise levels by using different number of light samples. 
  We can see that the with more light sampling, the noise level decreases.
  Further, compared to the uniform-hemisphere sampling, the importance sampling has lower noise level.
</p>
<div align="middle">
  <table style="width: 100%;">
    <tr align="center">
      <td>
        <img src="images/part3_s1_l1_CBbunny_importance.png" align="middle" width="200px"/>
        <figcaption><b>Figure 3i:</b> s = 1, l = 1</figcaption>
      </td>
      <td>
        <img src="images/part3_s1_l4_CBbunny_importance.png" align="middle" width="200px"/>
        <figcaption><b>Figure 3j:</b> s = 1, l = 4</figcaption>
      </td>
      <td>
        <img src="images/part3_s1_l16_CBbunny_importance.png" align="middle" width="200px"/>
        <figcaption><b>Figure 3k:</b> s = 1, l = 16</figcaption>
      </td>
      <td>
        <img src="images/part3_s1_l64_CBbunny_importance.png" align="middle" width="200px"/>
        <figcaption><b>Figure 3l:</b> s = 1, l = 64</figcaption>
      </td>
    </tr>
  </table>
</div>

<h2 align="middle">Part IV: Global Illumination</h2>

<p>
  In this part, the global illumination technique is implemented to simulate the indirect 
  lighting in the scene. The global illumination is implemented by recursively tracing the 
  bouncing rays in <code>PathTracer::at_least_one_bounce_radiance(...)</code>. The idea is 
  similar to apply the rendering function 
  $$
    L_o(p, \omega_o) = L_e(p, \omega_o) + \int_{H^2} f_r(p, \omega_i\rightarrow\omega_o)
    L_o(tr(p, \omega_i), -\omega_i) \cos \theta_i d\omega_i
  $$
  At each hit point, the next bouncing ray is generated by sampling around the hemisphere (which
  may cause additional noise). Below are some of the rendered results.
</p>
<div align="middle">
  <table style="width:100%">
    <tr align="center">
      <td>
        <img src="images/part4_CBspheres_lambertian_s1024_l16_m1.png" align="middle" width="400px"/>
        <figcaption>CBspheres (direct, s=1024, l=16, m=1)</figcaption>
      </td>
      <td>
        <img src="images/part4_CBspheres_lambertian_s1024_l16_m32.png" align="middle" width="400px"/>
        <figcaption>CBspheres (global, s=1024, l=16, m=32)</figcaption>
      </td>
    </tr>
    <tr align="center">
      <td>
        <img src="images/part4_CBbunny_s1024_l16_m1.png" align="middle" width="400px"/>
        <figcaption>CBbunny (direct, s=1024, l=16, m=1)</figcaption>
      </td>
      <td>
        <img src="images/part4_CBbunny_s1024_l16_m32.png" align="middle" width="400px"/>
        <figcaption>CBbunny (global, s=1024, l=16, m=32)</figcaption>
      </td>
    </tr>
    <tr align="center">
      <td>
        <img src="images/part4_CBbunny_s1024_l16_m1.png" align="middle" width="400px"/>
        <figcaption>CBbunny (direct, s=1024, l=16, m=1)</figcaption>
      </td>
      <td>
        <img src="images/part4_CBbunny_s1024_l16_m4.png" align="middle" width="400px"/>
        <figcaption>CBbunny (indirect, s=1024, l=16, m=4)</figcaption>
      </td>
    </tr>
  </table>
</div>

<p>
  Below are some of the images only using indirect illumination with different number of bounces. 
  From the 2nd and 3rd bounces, we can see that these two bounces significantly contribute
  more light in the dark area in the direct illumination image (especially on the body of the 
  bunny).
</p>

<div align="middle">
  <table style="width:100%">
    <tr align="center">
      <td>
        <img src="images/part4_CBbunny_s1024_l16_o0_m0.png" align="middle" width="250px"/>
        <figcaption>CBbunny (s=1024, l=16, m=0)</figcaption>
      </td>
      <td>
        <img src="images/part4_CBbunny_s1024_l16_o0_m1.png" align="middle" width="250px"/>
        <figcaption>CBbunny (s=1024, l=16, m=1)</figcaption>
      </td>
      <td>
        <img src="images/part4_CBbunny_s1024_l16_o0_m2.png" align="middle" width="250px"/>
        <figcaption>CBbunny (s=1024, l=16, m=2)</figcaption>
      </td>
    </tr>
    <tr align="center">
      <td>
        <img src="images/part4_CBbunny_s1024_l16_o0_m3.png" align="middle" width="250px"/>
        <figcaption>CBbunny (s=1024, l=16, m=3)</figcaption>
      </td>
      <td>
        <img src="images/part4_CBbunny_s1024_l16_o0_m4.png" align="middle" width="250px"/>
        <figcaption>CBbunny (s=1024, l=16, m=4)</figcaption>
      </td>
      <td>
        <img src="images/part4_CBbunny_s1024_l16_o0_m5.png" align="middle" width="250px"/>
        <figcaption>CBbunny (s=1024, l=16, m=5)</figcaption>
      </td>
    </tr>
  </table>
</div>

<p>
  Below are some of the images using global illumination with different number of bounces. 
</p>

<div align="middle">
  <table style="width:100%">
    <tr align="center">
      <td>
        <img src="images/part4_CBbunny_s1024_l16_o1_m0.png" align="middle" width="250px"/>
        <figcaption>CBbunny (s=1024, l=16, m=0)</figcaption>
      </td>
      <td>
        <img src="images/part4_CBbunny_s1024_l16_o1_m1.png" align="middle" width="250px"/>
        <figcaption>CBbunny (s=1024, l=16, m=1)</figcaption>
      </td>
      <td>
        <img src="images/part4_CBbunny_s1024_l16_o1_m2.png" align="middle" width="250px"/>
        <figcaption>CBbunny (s=1024, l=16, m=2)</figcaption>
      </td>
    </tr>
    <tr align="center">
      <td>
        <img src="images/part4_CBbunny_s1024_l16_o1_m3.png" align="middle" width="250px"/>
        <figcaption>CBbunny (s=1024, l=16, m=3)</figcaption>
      </td>
      <td>
        <img src="images/part4_CBbunny_s1024_l16_o1_m4.png" align="middle" width="250px"/>
        <figcaption>CBbunny (s=1024, l=16, m=4)</figcaption>
      </td>
      <td>
        <img src="images/part4_CBbunny_s1024_l16_o1_m5.png" align="middle" width="250px"/>
        <figcaption>CBbunny (s=1024, l=16, m=5)</figcaption>
      </td>
    </tr>
  </table>
</div>

<p>
  Below are some of the images using Russian Roulette rendering with different number of bounces. 
</p>

<div align="middle">
  <table style="width:100%">
    <tr align="center">
      <td>
        <img src="images/part4_CBbunny_s1024_l16_o1_m0_russian.png" align="middle" width="250px"/>
        <figcaption>CBbunny (s=1024, l=16, m=0)</figcaption>
      </td>
      <td>
        <img src="images/part4_CBbunny_s1024_l16_o1_m1_russian.png" align="middle" width="250px"/>
        <figcaption>CBbunny (s=1024, l=16, m=1)</figcaption>
      </td>
      <td>
        <img src="images/part4_CBbunny_s1024_l16_o1_m2_russian.png" align="middle" width="250px"/>
        <figcaption>CBbunny (s=1024, l=16, m=2)</figcaption>
      </td>
    </tr>
    <tr align="center">
      <td>
        <img src="images/part4_CBbunny_s1024_l16_o1_m3_russian.png" align="middle" width="250px"/>
        <figcaption>CBbunny (s=1024, l=16, m=3)</figcaption>
      </td>
      <td>
        <img src="images/part4_CBbunny_s1024_l16_o1_m4_russian.png" align="middle" width="250px"/>
        <figcaption>CBbunny (s=1024, l=16, m=4)</figcaption>
      </td>
      <td>
        <img src="images/part4_CBbunny_s1024_l16_o1_m100_russian.png" align="middle" width="250px"/>
        <figcaption>CBbunny (s=1024, l=16, m=5)</figcaption>
      </td>
    </tr>
  </table>
</div>

<p>
  Below are some of the images rendered with various sampler-per-pixel rates and different number of ray bounces. 
  Through these comparisons, we can see that the noise level decreases with the increase of the sampler-per-pixel rate. 
  When the sampler-per-pixel rate is high, the noise level is low, and the image is smooth.
  However, the path-tracing technique may introduce some additional noise, especially when the sample rate is low.
  This is because the path-tracing technique is a stochastic technique, and here it 
  uses uniform-hemisphere sampling to generate the bouncing rays (no better than importance sampling).
</p>

<div align="middle">
  <table style="width:100%">
    <tr align="center">
      <td>
        <img src="images/part4_CBbunny_s1_l4_o1_m1_final.png" align="middle" width="200px"/>
        <figcaption>CBbunny (s=1, l=4, m=1)</figcaption>
      </td>
      <td>
        <img src="images/part4_CBbunny_s1_l4_o1_m2_final.png" align="middle" width="200px"/>
        <figcaption>CBbunny (s=1, l=4, m=2)</figcaption>
      </td>
      <td>
        <img src="images/part4_CBbunny_s1_l4_o1_m3_final.png" align="middle" width="200px"/>
        <figcaption>CBbunny (s=1, l=4, m=4)</figcaption>
      </td>
      <td>
        <img src="images/part4_CBbunny_s1_l4_o1_m4_final.png" align="middle" width="200px"/>
        <figcaption>CBbunny (s=1, l=4, m=4)</figcaption>
      </td>
    </tr>
    <tr align="center">
      <td>
        <img src="images/part4_CBbunny_s2_l4_o1_m1_final.png" align="middle" width="200px"/>
        <figcaption>CBbunny (s=2, l=4, m=1)</figcaption>
      </td>
      <td>
        <img src="images/part4_CBbunny_s2_l4_o1_m2_final.png" align="middle" width="200px"/>
        <figcaption>CBbunny (s=2, l=4, m=2)</figcaption>
      </td>
      <td>
        <img src="images/part4_CBbunny_s2_l4_o1_m3_final.png" align="middle" width="200px"/>
        <figcaption>CBbunny (s=2, l=4, m=4)</figcaption>
      </td>
      <td>
        <img src="images/part4_CBbunny_s2_l4_o1_m4_final.png" align="middle" width="200px"/>
        <figcaption>CBbunny (s=2, l=4, m=4)</figcaption>
      </td>
    </tr>
    <tr align="center">
      <td>
        <img src="images/part4_CBbunny_s4_l4_o1_m1_final.png" align="middle" width="200px"/>
        <figcaption>CBbunny (s=4, l=4, m=1)</figcaption>
      </td>
      <td>
        <img src="images/part4_CBbunny_s4_l4_o1_m2_final.png" align="middle" width="200px"/>
        <figcaption>CBbunny (s=4, l=4, m=2)</figcaption>
      </td>
      <td>
        <img src="images/part4_CBbunny_s4_l4_o1_m3_final.png" align="middle" width="200px"/>
        <figcaption>CBbunny (s=4, l=4, m=4)</figcaption>
      </td>
      <td>
        <img src="images/part4_CBbunny_s4_l4_o1_m4_final.png" align="middle" width="200px"/>
        <figcaption>CBbunny (s=4, l=4, m=4)</figcaption>
      </td>
    </tr>
    <tr align="center">
      <td>
        <img src="images/part4_CBbunny_s8_l4_o1_m1_final.png" align="middle" width="200px"/>
        <figcaption>CBbunny (s=8, l=4, m=1)</figcaption>
      </td>
      <td>
        <img src="images/part4_CBbunny_s8_l4_o1_m2_final.png" align="middle" width="200px"/>
        <figcaption>CBbunny (s=8, l=4, m=2)</figcaption>
      </td>
      <td>
        <img src="images/part4_CBbunny_s8_l4_o1_m3_final.png" align="middle" width="200px"/>
        <figcaption>CBbunny (s=8, l=4, m=4)</figcaption>
      </td>
      <td>
        <img src="images/part4_CBbunny_s8_l4_o1_m4_final.png" align="middle" width="200px"/>
        <figcaption>CBbunny (s=8, l=4, m=4)</figcaption>
      </td>
    </tr>
    <tr align="center">
      <td>
        <img src="images/part4_CBbunny_s16_l4_o1_m1_final.png" align="middle" width="200px"/>
        <figcaption>CBbunny (s=16, l=4, m=1)</figcaption>
      </td>
      <td>
        <img src="images/part4_CBbunny_s16_l4_o1_m2_final.png" align="middle" width="200px"/>
        <figcaption>CBbunny (s=16, l=4, m=2)</figcaption>
      </td>
      <td>
        <img src="images/part4_CBbunny_s16_l4_o1_m3_final.png" align="middle" width="200px"/>
        <figcaption>CBbunny (s=16, l=4, m=4)</figcaption>
      </td>
      <td>
        <img src="images/part4_CBbunny_s16_l4_o1_m4_final.png" align="middle" width="200px"/>
        <figcaption>CBbunny (s=16, l=4, m=4)</figcaption>
      </td>
    </tr>
    <tr align="center">
      <td>
        <img src="images/part4_CBbunny_s64_l4_o1_m1_final.png" align="middle" width="200px"/>
        <figcaption>CBbunny (s=64, l=4, m=1)</figcaption>
      </td>
      <td>
        <img src="images/part4_CBbunny_s64_l4_o1_m2_final.png" align="middle" width="200px"/>
        <figcaption>CBbunny (s=64, l=4, m=2)</figcaption>
      </td>
      <td>
        <img src="images/part4_CBbunny_s64_l4_o1_m3_final.png" align="middle" width="200px"/>
        <figcaption>CBbunny (s=64, l=4, m=4)</figcaption>
      </td>
      <td>
        <img src="images/part4_CBbunny_s64_l4_o1_m4_final.png" align="middle" width="200px"/>
        <figcaption>CBbunny (s=64, l=4, m=4)</figcaption>
      </td>
    </tr>
    <tr align="center">
      <td>
        <img src="images/part4_CBbunny_s1024_l4_o1_m1_final.png" align="middle" width="200px"/>
        <figcaption>CBbunny (s=1024, l=4, m=1)</figcaption>
      </td>
      <td>
        <img src="images/part4_CBbunny_s1024_l4_o1_m2_final.png" align="middle" width="200px"/>
        <figcaption>CBbunny (s=1024, l=4, m=2)</figcaption>
      </td>
      <td>
        <img src="images/part4_CBbunny_s1024_l4_o1_m3_final.png" align="middle" width="200px"/>
        <figcaption>CBbunny (s=1024, l=4, m=4)</figcaption>
      </td>
      <td>
        <img src="images/part4_CBbunny_s1024_l4_o1_m4_final.png" align="middle" width="200px"/>
        <figcaption>CBbunny (s=1024, l=4, m=4)</figcaption>
      </td>
    </tr>
  </table>
</div>


<script>
  renderMathInElement(
    document.body,
    {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "\\[", right: "\\]", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false }
      ]
    }
  );
</script>
</body>
</html>